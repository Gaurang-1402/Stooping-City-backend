import { comparePassword, hashPassword } from "../Helpers/bcryptHash"
import User from "../Models/userModel"
// npm i jsonwebtoken
import jwt from "jsonwebtoken"

exports.registerController = async (req, res) => {
  const {
    firstName,
    lastName,
    email,
    password,
    confirmPassword,
    age,
    gender,
    secret,
  } = req.body

  // validation

  if (!firstName || !lastName)
    return res.status(400).send("Please provide your first name and last name")

  if (!age) return res.status(400).send("Please enter your age")

  const isEmailExist = await User.findOne({ email })

  if (isEmailExist)
    return res.status(400).send("This email is already in use. Please login")

  if (!password || password.length < 6)
    return res
      .status(400)
      .send("Please provide a password with more than 6 characters")
  if (password !== confirmPassword)
    return res.status(400).send("The passwords do not match :(")
  const hashedPassword = await hashPassword(password)

  if (!secret)
    return res
      .status(400)
      .send("Please enter an answer to the security question")

  const newUser = new User({
    firstName,
    lastName,
    email,
    password: hashedPassword,
    age,
    gender,
    secret,
  })

  try {
    await newUser.save()
    return res.json({ ok: true })
  } catch (err) {
    return res.status(400).send("There was an error, please try again")
  }
}

exports.loginController = async (req, res) => {
  try {
    const { email, password } = req.body

    /// validation

    // since email is unique, we can query in the DB using email to find the user
    // object associated with that email
    const user = await User.findOne({ email })
    if (!user) {
      return res
        .status(400)
        .send("Email not found. Please check your email or sign up.")
    }

    // we know that the password in DB is hashed, we can unhash and check if
    // the password we find through
    const isPasswordMatch = await comparePassword(password, user.password)

    if (!isPasswordMatch) {
      return res.status(400).send("Password is incorrect")
    }

    /// jwt.sign() gives us a token back the params are
    /// jwt.sign({<the fields that we need to save in token>}, <JWT secret we stored>, <how long till the token expires>)
    /// _id is auto generated by MongoDB

    const jwtToken = jwt.sign({ _id: user._id }, process.env.JWT_SECRET, {
      expiresIn: "7d",
    })

    // we are gonna send user and we don't want client to have
    // the ability to modify passwords and secret
    user.password = undefined
    user.secret = undefined

    // send jwt token and the user object to client
    return res.json({
      token: jwtToken,
      user,
    })

    return res.send("hello")
  } catch (err) {
    console.log(err)
    return res.status(400).send("An error occurred, please try again.")
  }
}

exports.currentUser = async (req, res) => {
  try {
    // beecause of the middleware in the route, we can see the extracted
    // information in the JSON web token
    // console.log(req.user)

    const user = await User.findById(req.user._id)
    return res.json({
      ok: true,
    })
  } catch (err) {
    console.log(err)
    return res.sendStatus(400)
  }
}
